<!DOCTYPE html>
<html devsite="">
  <head>
    <meta name="project_path" value="/dotnet/_project.yaml">
    <meta name="book_path" value="/dotnet/_book.yaml">
  </head>
  <body>
    <div>
      <h1 class="page-title">Namespace Google.Cloud.Spanner.V1
</h1>
      <article data-uid="Google.Cloud.Spanner.V1">
  
  <div class="markdown level0 summary"></div>
  <div class="markdown level0 conceptual"></div>
  <div class="markdown level0 remarks"></div>
    <h2 id="classes">Classes
  
  </h2>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.BatchCreateSessionsRequest.html">BatchCreateSessionsRequest</a></h3>
      <section><p>The request for [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.BatchCreateSessionsResponse.html">BatchCreateSessionsResponse</a></h3>
      <section><p>The response for [BatchCreateSessions][google.spanner.v1.Spanner.BatchCreateSessions].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.BeginTransactionRequest.html">BeginTransactionRequest</a></h3>
      <section><p>The request for [BeginTransaction][google.spanner.v1.Spanner.BeginTransaction].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.CommitRequest.html">CommitRequest</a></h3>
      <section><p>The request for [Commit][google.spanner.v1.Spanner.Commit].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.CommitResponse.html">CommitResponse</a></h3>
      <section><p>The response for [Commit][google.spanner.v1.Spanner.Commit].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.CommitResponse.Types.html">CommitResponse.Types</a></h3>
      <section><p>Container for nested types declared in the CommitResponse message type.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.CommitResponse.Types.CommitStats.html">CommitResponse.Types.CommitStats</a></h3>
      <section><p>Additional statistics about a commit.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.CreateSessionRequest.html">CreateSessionRequest</a></h3>
      <section><p>The request for [CreateSession][google.spanner.v1.Spanner.CreateSession].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.DeleteSessionRequest.html">DeleteSessionRequest</a></h3>
      <section><p>The request for [DeleteSession][google.spanner.v1.Spanner.DeleteSession].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ExecuteBatchDmlRequest.html">ExecuteBatchDmlRequest</a></h3>
      <section><p>The request for [ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchDml].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ExecuteBatchDmlRequest.Types.html">ExecuteBatchDmlRequest.Types</a></h3>
      <section><p>Container for nested types declared in the ExecuteBatchDmlRequest message type.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ExecuteBatchDmlRequest.Types.Statement.html">ExecuteBatchDmlRequest.Types.Statement</a></h3>
      <section><p>A single DML statement.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ExecuteBatchDmlResponse.html">ExecuteBatchDmlResponse</a></h3>
      <section><p>The response for [ExecuteBatchDml][google.spanner.v1.Spanner.ExecuteBatchDml]. Contains a list
of [ResultSet][google.spanner.v1.ResultSet] messages, one for each DML statement that has successfully
executed, in the same order as the statements in the request. If a statement
fails, the status in the response body identifies the cause of the failure.</p>
<p>To check for DML statements that failed, use the following approach:</p>
<ol>
<li>Check the status in the response message. The [google.rpc.Code][google.rpc.Code] enum
value <code>OK</code> indicates that all statements were executed successfully.</li>
<li>If the status was not <code>OK</code>, check the number of result sets in the
response. If the response contains <code>N</code> [ResultSet][google.spanner.v1.ResultSet] messages, then
statement <code>N+1</code> in the request failed.</li>
</ol>
<p>Example 1:</p>
<ul>
<li>Request: 5 DML statements, all executed successfully.</li>
<li>Response: 5 [ResultSet][google.spanner.v1.ResultSet] messages, with the status <code>OK</code>.</li>
</ul>
<p>Example 2:</p>
<ul>
<li>Request: 5 DML statements. The third statement has a syntax error.</li>
<li>Response: 2 [ResultSet][google.spanner.v1.ResultSet] messages, and a syntax error (<code>INVALID_ARGUMENT</code>)
status. The number of [ResultSet][google.spanner.v1.ResultSet] messages indicates that the third
statement failed, and the fourth and fifth statements were not executed.</li>
</ul>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ExecuteSqlRequest.html">ExecuteSqlRequest</a></h3>
      <section><p>The request for [ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] and
[ExecuteStreamingSql][google.spanner.v1.Spanner.ExecuteStreamingSql].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ExecuteSqlRequest.Types.html">ExecuteSqlRequest.Types</a></h3>
      <section><p>Container for nested types declared in the ExecuteSqlRequest message type.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ExecuteSqlRequest.Types.QueryOptions.html">ExecuteSqlRequest.Types.QueryOptions</a></h3>
      <section><p>Query optimizer configuration.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.GetSessionRequest.html">GetSessionRequest</a></h3>
      <section><p>The request for [GetSession][google.spanner.v1.Spanner.GetSession].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.KeyRange.html">KeyRange</a></h3>
      <section><p>KeyRange represents a range of rows in a table or index.</p>
<p>A range has a start key and an end key. These keys can be open or
closed, indicating if the range includes rows with that key.</p>
<p>Keys are represented by lists, where the ith value in the list
corresponds to the ith component of the table or index primary key.
Individual values are encoded as described
[here][google.spanner.v1.TypeCode].</p>
<p>For example, consider the following table definition:</p>
<p>CREATE TABLE UserEvents (
 UserName STRING(MAX),
 EventDate STRING(10)
) PRIMARY KEY(UserName, EventDate);</p>
<p>The following keys name rows in this table:</p>
<p>[&quot;Bob&quot;, &quot;2014-09-23&quot;]
[&quot;Alfred&quot;, &quot;2015-06-12&quot;]</p>
<p>Since the <code>UserEvents</code> table&apos;s <code>PRIMARY KEY</code> clause names two
columns, each <code>UserEvents</code> key has two elements; the first is the
<code>UserName</code>, and the second is the <code>EventDate</code>.</p>
<p>Key ranges with multiple components are interpreted
lexicographically by component using the table or index key&apos;s declared
sort order. For example, the following range returns all events for
user <code>&amp;quot;Bob&amp;quot;</code> that occurred in the year 2015:</p>
<p>&quot;start_closed&quot;: [&quot;Bob&quot;, &quot;2015-01-01&quot;]
&quot;end_closed&quot;: [&quot;Bob&quot;, &quot;2015-12-31&quot;]</p>
<p>Start and end keys can omit trailing key components. This affects the
inclusion and exclusion of rows that exactly match the provided key
components: if the key is closed, then rows that exactly match the
provided components are included; if the key is open, then rows
that exactly match are not included.</p>
<p>For example, the following range includes all events for <code>&amp;quot;Bob&amp;quot;</code> that
occurred during and after the year 2000:</p>
<p>&quot;start_closed&quot;: [&quot;Bob&quot;, &quot;2000-01-01&quot;]
&quot;end_closed&quot;: [&quot;Bob&quot;]</p>
<p>The next example retrieves all events for <code>&amp;quot;Bob&amp;quot;</code>:</p>
<p>&quot;start_closed&quot;: [&quot;Bob&quot;]
&quot;end_closed&quot;: [&quot;Bob&quot;]</p>
<p>To retrieve events before the year 2000:</p>
<p>&quot;start_closed&quot;: [&quot;Bob&quot;]
&quot;end_open&quot;: [&quot;Bob&quot;, &quot;2000-01-01&quot;]</p>
<p>The following range includes all rows in the table:</p>
<p>&quot;start_closed&quot;: []
&quot;end_closed&quot;: []</p>
<p>This range returns all users whose <code>UserName</code> begins with any
character from A to C:</p>
<p>&quot;start_closed&quot;: [&quot;A&quot;]
&quot;end_open&quot;: [&quot;D&quot;]</p>
<p>This range returns all users whose <code>UserName</code> begins with B:</p>
<p>&quot;start_closed&quot;: [&quot;B&quot;]
&quot;end_open&quot;: [&quot;C&quot;]</p>
<p>Key ranges honor column sort order. For example, suppose a table is
defined as follows:</p>
<p>CREATE TABLE DescendingSortedTable {
 Key INT64,
 ...
) PRIMARY KEY(Key DESC);</p>
<p>The following range retrieves all rows with key values between 1
and 100 inclusive:</p>
<p>&quot;start_closed&quot;: [&quot;100&quot;]
&quot;end_closed&quot;: [&quot;1&quot;]</p>
<p>Note that 100 is passed as the start, and 1 is passed as the end,
because <code>Key</code> is a descending column in the schema.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.KeySet.html">KeySet</a></h3>
      <section><p><code>KeySet</code> defines a collection of Cloud Spanner keys and/or key ranges. All
the keys are expected to be in the same table or index. The keys need
not be sorted in any particular way.</p>
<p>If the same key is specified multiple times in the set (for example
if two ranges, two keys, or a key and a range overlap), Cloud Spanner
behaves as if the key were only specified once.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ListSessionsRequest.html">ListSessionsRequest</a></h3>
      <section><p>The request for [ListSessions][google.spanner.v1.Spanner.ListSessions].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ListSessionsResponse.html">ListSessionsResponse</a></h3>
      <section><p>The response for [ListSessions][google.spanner.v1.Spanner.ListSessions].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Mutation.html">Mutation</a></h3>
      <section><p>A modification to one or more Cloud Spanner rows.  Mutations can be
applied to a Cloud Spanner database by sending them in a
[Commit][google.spanner.v1.Spanner.Commit] call.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Mutation.Types.html">Mutation.Types</a></h3>
      <section><p>Container for nested types declared in the Mutation message type.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Mutation.Types.Delete.html">Mutation.Types.Delete</a></h3>
      <section><p>Arguments to [delete][google.spanner.v1.Mutation.delete] operations.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Mutation.Types.Write.html">Mutation.Types.Write</a></h3>
      <section><p>Arguments to [insert][google.spanner.v1.Mutation.insert], [update][google.spanner.v1.Mutation.update], [insert_or_update][google.spanner.v1.Mutation.insert_or_update], and
[replace][google.spanner.v1.Mutation.replace] operations.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PartialResultSet.html">PartialResultSet</a></h3>
      <section><p>Partial results from a streaming read or SQL query. Streaming reads and
SQL queries better tolerate large result sets, large rows, and large
values, but are a little trickier to consume.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Partition.html">Partition</a></h3>
      <section><p>Information returned for each partition returned in a
PartitionResponse.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PartitionOptions.html">PartitionOptions</a></h3>
      <section><p>Options for a PartitionQueryRequest and
PartitionReadRequest.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PartitionQueryRequest.html">PartitionQueryRequest</a></h3>
      <section><p>The request for [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PartitionReadRequest.html">PartitionReadRequest</a></h3>
      <section><p>The request for [PartitionRead][google.spanner.v1.Spanner.PartitionRead]</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PartitionResponse.html">PartitionResponse</a></h3>
      <section><p>The response for [PartitionQuery][google.spanner.v1.Spanner.PartitionQuery]
or [PartitionRead][google.spanner.v1.Spanner.PartitionRead]</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PlanNode.html">PlanNode</a></h3>
      <section><p>Node information for nodes appearing in a [QueryPlan.plan_nodes][google.spanner.v1.QueryPlan.plan_nodes].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PlanNode.Types.html">PlanNode.Types</a></h3>
      <section><p>Container for nested types declared in the PlanNode message type.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PlanNode.Types.ChildLink.html">PlanNode.Types.ChildLink</a></h3>
      <section><p>Metadata associated with a parent-child relationship appearing in a
[PlanNode][google.spanner.v1.PlanNode].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PlanNode.Types.ShortRepresentation.html">PlanNode.Types.ShortRepresentation</a></h3>
      <section><p>Condensed representation of a node and its subtree. Only present for
<code>SCALAR</code> [PlanNode(s)][google.spanner.v1.PlanNode].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PooledSession.html">PooledSession</a></h3>
      <section><p>A session from a <a class="xref" href="Google.Cloud.Spanner.V1.SessionPool.html">SessionPool</a>, with an associated transaction if
requested. Instances must be released back to the pool via <a class="xref" href="Google.Cloud.Spanner.V1.PooledSession.html#Google_Cloud_Spanner_V1_PooledSession_ReleaseToPool_System_Boolean_">ReleaseToPool(Boolean)</a>.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.QueryPlan.html">QueryPlan</a></h3>
      <section><p>Contains an ordered list of nodes appearing in the query plan.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ReadRequest.html">ReadRequest</a></h3>
      <section><p>The request for [Read][google.spanner.v1.Spanner.Read] and
[StreamingRead][google.spanner.v1.Spanner.StreamingRead].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ReliableStreamReader.html">ReliableStreamReader</a></h3>
      <section><p>Provides streaming access to a Spanner SQL query that automatically retries, handles
chunking and recoverable errors.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ResultSet.html">ResultSet</a></h3>
      <section><p>Results from [Read][google.spanner.v1.Spanner.Read] or
[ExecuteSql][google.spanner.v1.Spanner.ExecuteSql].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ResultSetMetadata.html">ResultSetMetadata</a></h3>
      <section><p>Metadata about a [ResultSet][google.spanner.v1.ResultSet] or [PartialResultSet][google.spanner.v1.PartialResultSet].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ResultSetStats.html">ResultSetStats</a></h3>
      <section><p>Additional statistics about a [ResultSet][google.spanner.v1.ResultSet] or [PartialResultSet][google.spanner.v1.PartialResultSet].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.RollbackRequest.html">RollbackRequest</a></h3>
      <section><p>The request for [Rollback][google.spanner.v1.Spanner.Rollback].</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Session.html">Session</a></h3>
      <section><p>A session in the Cloud Spanner API.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SessionName.html">SessionName</a></h3>
      <section><p>Resource name for the <code>Session</code> resource.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SessionPool.html">SessionPool</a></h3>
      <section><p>A pool of sessions associated with a SpannerClient.
Sessions can be acquired by specifying the desired transaction options, if any.
A session/transaction pair is then returned, which should be returned to the pool when
it is no longer required. Sessions are kept alive automatically, and retired if they
are expired by the server.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SessionPool.DatabaseStatistics.html">SessionPool.DatabaseStatistics</a></h3>
      <section><p>A snapshot of statistics for one database within a <a class="xref" href="Google.Cloud.Spanner.V1.SessionPool.html">SessionPool</a>.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SessionPool.Statistics.html">SessionPool.Statistics</a></h3>
      <section><p>A snapshot of statistics for a <a class="xref" href="Google.Cloud.Spanner.V1.SessionPool.html">SessionPool</a>.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SessionPoolOptions.html">SessionPoolOptions</a></h3>
      <section><p>Options for session pools.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Spanner.html">Spanner</a></h3>
      <section><p>Cloud Spanner API</p>
<p>The Cloud Spanner API can be used to manage sessions and execute
transactions on data stored in Cloud Spanner databases.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Spanner.SpannerBase.html">Spanner.SpannerBase</a></h3>
      <section><p>Base class for server-side implementations of Spanner</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Spanner.SpannerClient.html">Spanner.SpannerClient</a></h3>
      <section><p>Client for Spanner</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SpannerClient.html">SpannerClient</a></h3>
      <section><p>Spanner client wrapper, for convenient use.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SpannerClient.ExecuteStreamingSqlStream.html">SpannerClient.ExecuteStreamingSqlStream</a></h3>
      <section><p>Server streaming methods for <a class="xref" href="Google.Cloud.Spanner.V1.SpannerClient.html#Google_Cloud_Spanner_V1_SpannerClient_ExecuteStreamingSql_Google_Cloud_Spanner_V1_ExecuteSqlRequest_Google_Api_Gax_Grpc_CallSettings_">ExecuteStreamingSql(ExecuteSqlRequest, CallSettings)</a>.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SpannerClient.StreamingReadStream.html">SpannerClient.StreamingReadStream</a></h3>
      <section><p>Server streaming methods for <a class="xref" href="Google.Cloud.Spanner.V1.SpannerClient.html#Google_Cloud_Spanner_V1_SpannerClient_StreamingRead_Google_Cloud_Spanner_V1_ReadRequest_Google_Api_Gax_Grpc_CallSettings_">StreamingRead(ReadRequest, CallSettings)</a>.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SpannerClientBuilder.html">SpannerClientBuilder</a></h3>
      <section><p>Builder class for <a class="xref" href="Google.Cloud.Spanner.V1.SpannerClient.html">SpannerClient</a> to provide simple configuration of credentials, endpoint etc.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SpannerClientImpl.html">SpannerClientImpl</a></h3>
      <section><p>Spanner client wrapper implementation, for convenient use.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SpannerSettings.html">SpannerSettings</a></h3>
      <section><p>Settings for <a class="xref" href="Google.Cloud.Spanner.V1.SpannerClient.html">SpannerClient</a> instances.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.StreamClosedEventArgs.html">StreamClosedEventArgs</a></h3>
      <section><p>Event argument type for <a class="xref" href="Google.Cloud.Spanner.V1.ReliableStreamReader.html#Google_Cloud_Spanner_V1_ReliableStreamReader_StreamClosed">StreamClosed</a>.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.StructType.html">StructType</a></h3>
      <section><p><code>StructType</code> defines the fields of a [STRUCT][google.spanner.v1.TypeCode.STRUCT] type.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.StructType.Types.html">StructType.Types</a></h3>
      <section><p>Container for nested types declared in the StructType message type.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.StructType.Types.Field.html">StructType.Types.Field</a></h3>
      <section><p>Message representing a single field of a struct.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Transaction.html">Transaction</a></h3>
      <section><p>A transaction.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TransactionOptions.html">TransactionOptions</a></h3>
      <section><h1 id="transactions">Transactions</h1>
<p>Each session can have at most one active transaction at a time (note that
standalone reads and queries use a transaction internally and do count
towards the one transaction limit). After the active transaction is
completed, the session can immediately be re-used for the next transaction.
It is not necessary to create a new session for each transaction.</p>
<h1 id="transaction-modes">Transaction Modes</h1>
<p>Cloud Spanner supports three transaction modes:</p>
<ol>
<li><p>Locking read-write. This type of transaction is the only way
to write data into Cloud Spanner. These transactions rely on
pessimistic locking and, if necessary, two-phase commit.
Locking read-write transactions may abort, requiring the
application to retry.</p>
</li>
<li><p>Snapshot read-only. This transaction type provides guaranteed
consistency across several reads, but does not allow
writes. Snapshot read-only transactions can be configured to
read at timestamps in the past. Snapshot read-only
transactions do not need to be committed.</p>
</li>
<li><p>Partitioned DML. This type of transaction is used to execute
a single Partitioned DML statement. Partitioned DML partitions
the key space and runs the DML statement over each partition
in parallel using separate, internal transactions that commit
independently. Partitioned DML transactions do not need to be
committed.</p>
</li>
</ol>
<p>For transactions that only read, snapshot read-only transactions
provide simpler semantics and are almost always faster. In
particular, read-only transactions do not take locks, so they do
not conflict with read-write transactions. As a consequence of not
taking locks, they also do not abort, so retry loops are not needed.</p>
<p>Transactions may only read/write data in a single database. They
may, however, read/write data in different tables within that
database.</p>
<h2 id="locking-read-write-transactions">Locking Read-Write Transactions</h2>
<p>Locking transactions may be used to atomically read-modify-write
data anywhere in a database. This type of transaction is externally
consistent.</p>
<p>Clients should attempt to minimize the amount of time a transaction
is active. Faster transactions commit with higher probability
and cause less contention. Cloud Spanner attempts to keep read locks
active as long as the transaction continues to do reads, and the
transaction has not been terminated by
[Commit][google.spanner.v1.Spanner.Commit] or
[Rollback][google.spanner.v1.Spanner.Rollback].  Long periods of
inactivity at the client may cause Cloud Spanner to release a
transaction&apos;s locks and abort it.</p>
<p>Conceptually, a read-write transaction consists of zero or more
reads or SQL statements followed by
[Commit][google.spanner.v1.Spanner.Commit]. At any time before
[Commit][google.spanner.v1.Spanner.Commit], the client can send a
[Rollback][google.spanner.v1.Spanner.Rollback] request to abort the
transaction.</p>
<h3 id="semantics">Semantics</h3>
<p>Cloud Spanner can commit the transaction if all read locks it acquired
are still valid at commit time, and it is able to acquire write
locks for all writes. Cloud Spanner can abort the transaction for any
reason. If a commit attempt returns <code>ABORTED</code>, Cloud Spanner guarantees
that the transaction has not modified any user data in Cloud Spanner.</p>
<p>Unless the transaction commits, Cloud Spanner makes no guarantees about
how long the transaction&apos;s locks were held for. It is an error to
use Cloud Spanner locks for any sort of mutual exclusion other than
between Cloud Spanner transactions themselves.</p>
<h3 id="retrying-aborted-transactions">Retrying Aborted Transactions</h3>
<p>When a transaction aborts, the application can choose to retry the
whole transaction again. To maximize the chances of successfully
committing the retry, the client should execute the retry in the
same session as the original attempt. The original session&apos;s lock
priority increases with each consecutive abort, meaning that each
attempt has a slightly better chance of success than the previous.</p>
<p>Under some circumstances (e.g., many transactions attempting to
modify the same row(s)), a transaction can abort many times in a
short period before successfully committing. Thus, it is not a good
idea to cap the number of retries a transaction can attempt;
instead, it is better to limit the total amount of wall time spent
retrying.</p>
<h3 id="idle-transactions">Idle Transactions</h3>
<p>A transaction is considered idle if it has no outstanding reads or
SQL queries and has not started a read or SQL query within the last 10
seconds. Idle transactions can be aborted by Cloud Spanner so that they
don&apos;t hold on to locks indefinitely. In that case, the commit will
fail with error <code>ABORTED</code>.</p>
<p>If this behavior is undesirable, periodically executing a simple
SQL query in the transaction (e.g., <code>SELECT 1</code>) prevents the
transaction from becoming idle.</p>
<h2 id="snapshot-read-only-transactions">Snapshot Read-Only Transactions</h2>
<p>Snapshot read-only transactions provides a simpler method than
locking read-write transactions for doing several consistent
reads. However, this type of transaction does not support writes.</p>
<p>Snapshot transactions do not take locks. Instead, they work by
choosing a Cloud Spanner timestamp, then executing all reads at that
timestamp. Since they do not acquire locks, they do not block
concurrent read-write transactions.</p>
<p>Unlike locking read-write transactions, snapshot read-only
transactions never abort. They can fail if the chosen read
timestamp is garbage collected; however, the default garbage
collection policy is generous enough that most applications do not
need to worry about this in practice.</p>
<p>Snapshot read-only transactions do not need to call
[Commit][google.spanner.v1.Spanner.Commit] or
[Rollback][google.spanner.v1.Spanner.Rollback] (and in fact are not
permitted to do so).</p>
<p>To execute a snapshot transaction, the client specifies a timestamp
bound, which tells Cloud Spanner how to choose a read timestamp.</p>
<p>The types of timestamp bound are:</p>
<ul>
<li>Strong (the default).</li>
<li>Bounded staleness.</li>
<li>Exact staleness.</li>
</ul>
<p>If the Cloud Spanner database to be read is geographically distributed,
stale read-only transactions can execute more quickly than strong
or read-write transaction, because they are able to execute far
from the leader replica.</p>
<p>Each type of timestamp bound is discussed in detail below.</p>
<h3 id="strong">Strong</h3>
<p>Strong reads are guaranteed to see the effects of all transactions
that have committed before the start of the read. Furthermore, all
rows yielded by a single read are consistent with each other -- if
any part of the read observes a transaction, all parts of the read
see the transaction.</p>
<p>Strong reads are not repeatable: two consecutive strong read-only
transactions might return inconsistent results if there are
concurrent writes. If consistency across reads is required, the
reads should be executed within a transaction or at an exact read
timestamp.</p>
<p>See [TransactionOptions.ReadOnly.strong][google.spanner.v1.TransactionOptions.ReadOnly.strong].</p>
<h3 id="exact-staleness">Exact Staleness</h3>
<p>These timestamp bounds execute reads at a user-specified
timestamp. Reads at a timestamp are guaranteed to see a consistent
prefix of the global transaction history: they observe
modifications done by all transactions with a commit timestamp &lt;=
the read timestamp, and observe none of the modifications done by
transactions with a larger commit timestamp. They will block until
all conflicting transactions that may be assigned commit timestamps
&lt;= the read timestamp have finished.</p>
<p>The timestamp can either be expressed as an absolute Cloud Spanner commit
timestamp or a staleness relative to the current time.</p>
<p>These modes do not require a &quot;negotiation phase&quot; to pick a
timestamp. As a result, they execute slightly faster than the
equivalent boundedly stale concurrency modes. On the other hand,
boundedly stale reads usually return fresher results.</p>
<p>See [TransactionOptions.ReadOnly.read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.read_timestamp] and
[TransactionOptions.ReadOnly.exact_staleness][google.spanner.v1.TransactionOptions.ReadOnly.exact_staleness].</p>
<h3 id="bounded-staleness">Bounded Staleness</h3>
<p>Bounded staleness modes allow Cloud Spanner to pick the read timestamp,
subject to a user-provided staleness bound. Cloud Spanner chooses the
newest timestamp within the staleness bound that allows execution
of the reads at the closest available replica without blocking.</p>
<p>All rows yielded are consistent with each other -- if any part of
the read observes a transaction, all parts of the read see the
transaction. Boundedly stale reads are not repeatable: two stale
reads, even if they use the same staleness bound, can execute at
different timestamps and thus return inconsistent results.</p>
<p>Boundedly stale reads execute in two phases: the first phase
negotiates a timestamp among all replicas needed to serve the
read. In the second phase, reads are executed at the negotiated
timestamp.</p>
<p>As a result of the two phase execution, bounded staleness reads are
usually a little slower than comparable exact staleness
reads. However, they are typically able to return fresher
results, and are more likely to execute at the closest replica.</p>
<p>Because the timestamp negotiation requires up-front knowledge of
which rows will be read, it can only be used with single-use
read-only transactions.</p>
<p>See [TransactionOptions.ReadOnly.max_staleness][google.spanner.v1.TransactionOptions.ReadOnly.max_staleness] and
[TransactionOptions.ReadOnly.min_read_timestamp][google.spanner.v1.TransactionOptions.ReadOnly.min_read_timestamp].</p>
<h3 id="old-read-timestamps-and-garbage-collection">Old Read Timestamps and Garbage Collection</h3>
<p>Cloud Spanner continuously garbage collects deleted and overwritten data
in the background to reclaim storage space. This process is known
as &quot;version GC&quot;. By default, version GC reclaims versions after they
are one hour old. Because of this, Cloud Spanner cannot perform reads
at read timestamps more than one hour in the past. This
restriction also applies to in-progress reads and/or SQL queries whose
timestamp become too old while executing. Reads and SQL queries with
too-old read timestamps fail with the error <code>FAILED_PRECONDITION</code>.</p>
<h2 id="partitioned-dml-transactions">Partitioned DML Transactions</h2>
<p>Partitioned DML transactions are used to execute DML statements with a
different execution strategy that provides different, and often better,
scalability properties for large, table-wide operations than DML in a
ReadWrite transaction. Smaller scoped statements, such as an OLTP workload,
should prefer using ReadWrite transactions.</p>
<p>Partitioned DML partitions the keyspace and runs the DML statement on each
partition in separate, internal transactions. These transactions commit
automatically when complete, and run independently from one another.</p>
<p>To reduce lock contention, this execution strategy only acquires read locks
on rows that match the WHERE clause of the statement. Additionally, the
smaller per-partition transactions hold locks for less time.</p>
<p>That said, Partitioned DML is not a drop-in replacement for standard DML used
in ReadWrite transactions.</p>
<ul>
<li><p>The DML statement must be fully-partitionable. Specifically, the statement
must be expressible as the union of many statements which each access only
a single row of the table.</p>
</li>
<li><p>The statement is not applied atomically to all rows of the table. Rather,
the statement is applied atomically to partitions of the table, in
independent transactions. Secondary index rows are updated atomically
with the base table rows.</p>
</li>
<li><p>Partitioned DML does not guarantee exactly-once execution semantics
against a partition. The statement will be applied at least once to each
partition. It is strongly recommended that the DML statement should be
idempotent to avoid unexpected results. For instance, it is potentially
dangerous to run a statement such as
<code>UPDATE table SET column = column + 1</code> as it could be run multiple times
against some rows.</p>
</li>
<li><p>The partitions are committed automatically - there is no support for
Commit or Rollback. If the call returns an error, or if the client issuing
the ExecuteSql call dies, it is possible that some rows had the statement
executed on them successfully. It is also possible that statement was
never executed against other rows.</p>
</li>
<li><p>Partitioned DML transactions may only contain the execution of a single
DML statement via ExecuteSql or ExecuteStreamingSql.</p>
</li>
<li><p>If any error is encountered during the execution of the partitioned DML
operation (for instance, a UNIQUE INDEX violation, division by zero, or a
value that cannot be stored due to schema constraints), then the
operation is stopped at that point and an error is returned. It is
possible that at this point, some partitions have been committed (or even
committed multiple times), and other partitions have not been run at all.</p>
</li>
</ul>
<p>Given the above, Partitioned DML is good fit for large, database-wide,
operations that are idempotent, such as deleting old rows from a very large
table.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TransactionOptions.Types.html">TransactionOptions.Types</a></h3>
      <section><p>Container for nested types declared in the TransactionOptions message type.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TransactionOptions.Types.PartitionedDml.html">TransactionOptions.Types.PartitionedDml</a></h3>
      <section><p>Message type to initiate a Partitioned DML transaction.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly.html">TransactionOptions.Types.ReadOnly</a></h3>
      <section><p>Message type to initiate a read-only transaction.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadWrite.html">TransactionOptions.Types.ReadWrite</a></h3>
      <section><p>Message type to initiate a read-write transaction. Currently this
transaction type has no options.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TransactionSelector.html">TransactionSelector</a></h3>
      <section><p>This message is used to select the transaction in which a
[Read][google.spanner.v1.Spanner.Read] or
[ExecuteSql][google.spanner.v1.Spanner.ExecuteSql] call runs.</p>
<p>See [TransactionOptions][google.spanner.v1.TransactionOptions] for more information about transactions.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Type.html">Type</a></h3>
      <section><p><code>Type</code> indicates the type of a Cloud Spanner value, as might be stored in a
table cell or returned from an SQL query.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TypeCodeExtensions.html">TypeCodeExtensions</a></h3>
      <section><p>Extension methods and factory methods for type codes.</p>
</section>
    <h2 id="structs">Structs
  
  </h2>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SpannerNumeric.html">SpannerNumeric</a></h3>
      <section><p>Representation of the Spanner NUMERIC type, which has 38 digits of precision,
and a fixed scale of 9 decimal places to the right of the decimal point</p>
</section>
    <h2 id="enums">Enums
  
  </h2>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.CommitRequest.TransactionOneofCase.html">CommitRequest.TransactionOneofCase</a></h3>
      <section><p>Enum of possible cases for the &quot;transaction&quot; oneof.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ExecuteSqlRequest.Types.QueryMode.html">ExecuteSqlRequest.Types.QueryMode</a></h3>
      <section><p>Mode in which the statement must be processed.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.KeyRange.EndKeyTypeOneofCase.html">KeyRange.EndKeyTypeOneofCase</a></h3>
      <section><p>Enum of possible cases for the &quot;end_key_type&quot; oneof.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.KeyRange.StartKeyTypeOneofCase.html">KeyRange.StartKeyTypeOneofCase</a></h3>
      <section><p>Enum of possible cases for the &quot;start_key_type&quot; oneof.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.LossOfPrecisionHandling.html">LossOfPrecisionHandling</a></h3>
      <section><p>Handling for a conversion that would lose precision.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.Mutation.OperationOneofCase.html">Mutation.OperationOneofCase</a></h3>
      <section><p>Enum of possible cases for the &quot;operation&quot; oneof.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.PlanNode.Types.Kind.html">PlanNode.Types.Kind</a></h3>
      <section><p>The kind of [PlanNode][google.spanner.v1.PlanNode]. Distinguishes between the two different kinds of
nodes that can appear in a query plan.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ResourcesExhaustedBehavior.html">ResourcesExhaustedBehavior</a></h3>
      <section><p>Specifies the behavior when <a class="xref" href="Google.Cloud.Spanner.V1.SessionPoolOptions.html#Google_Cloud_Spanner_V1_SessionPoolOptions_MaximumActiveSessions">MaximumActiveSessions</a>
is reached.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.ResultSetStats.RowCountOneofCase.html">ResultSetStats.RowCountOneofCase</a></h3>
      <section><p>Enum of possible cases for the &quot;row_count&quot; oneof.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.SessionName.ResourceNameType.html">SessionName.ResourceNameType</a></h3>
      <section><p>The possible contents of <a class="xref" href="Google.Cloud.Spanner.V1.SessionName.html">SessionName</a>.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TransactionOptions.ModeOneofCase.html">TransactionOptions.ModeOneofCase</a></h3>
      <section><p>Enum of possible cases for the &quot;mode&quot; oneof.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TransactionOptions.Types.ReadOnly.TimestampBoundOneofCase.html">TransactionOptions.Types.ReadOnly.TimestampBoundOneofCase</a></h3>
      <section><p>Enum of possible cases for the &quot;timestamp_bound&quot; oneof.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TransactionSelector.SelectorOneofCase.html">TransactionSelector.SelectorOneofCase</a></h3>
      <section><p>Enum of possible cases for the &quot;selector&quot; oneof.</p>
</section>
      <h3><a class="xref" href="Google.Cloud.Spanner.V1.TypeCode.html">TypeCode</a></h3>
      <section><p><code>TypeCode</code> is used as part of [Type][google.spanner.v1.Type] to
indicate the type of a Cloud Spanner value.</p>
<p>Each legal value of a type can be encoded to or decoded from a JSON
value, using the encodings described below. All Cloud Spanner values can
be <code>null</code>, regardless of type; <code>null</code>s are always encoded as a JSON
<code>null</code>.</p>
</section>
</article>
    </div>
  </body>
</html>
